[001. 整数除法](https://leetcode.cn/problems/xoh6Oh/)

### 解法一（时间复杂度：O((logn)^2)）:
#### 思路分析：
1. 首先考虑边界：
   32位有符号数的范围是[-2^30, 2^30-1], 而可能达到边界的情况有：  
   a. 被除数是最小值，除数是1的话不会溢出，直接返回结果就行  
   b. 被除数是最小值，除数是-1的话结果是2^30，会溢出，应返回最大值  
   c. 被除数是最大值，无论除数是1还是-1都不会溢出  
2. 为了便于计算，我们可以把被除数与除数都转化为负数，并设立一个变量sign用以标记这两个数的符号是否一致  
3. 最简单的思路是用被除数不断减去除数，每循环一次记录结果加一，直到被除数小于等于除数，结束循环并返回结果
4. 但是上述思路未经优化，极耗时间，下面考虑，每次循环被除数减去的数不是单纯的除数，而是除数的倍数。例如22/3，则可以这样计算：  
   22 - 3 > 0, 22 - (3 + 3) > 0, 22 - (6 + 6) > 0, 22 - (12 + 12) < 0, 所以记k1 = 12/3 = 4, 22 - 12 = 10  
   10 - 3 > 0, 10 - (3 + 3) > 0, 10 - (6 + 6) < 0, 所以记k2 = 6/3 = 2, 10 - 6 = 4  
   4 - 3 > 0, 4 - (3 + 3) < 0, 所以记k3 = 3/3 = 1, 4 - 3 = 1  
   1 - 3 < 0, 所以记k4 = 0  
   最后再将所有的k加起来即可得到最后结果是7
5. 这样做的好处是每轮循环都增大了被除数向0靠拢的步幅，可以降得很快
6. 时间复杂度分析：使用到了双重循环，内层循环中步幅每次都增加2倍所以是logn，外层循环中被除数每次减少一半左右所以是logn，故整体就是O((logn)^2)

#### CODE:

```
class Solution {
    public int divide(int a, int b) {
        if (a == Integer.MIN_VALUE) {
            if (b == 1) {
                return Integer.MIN_VALUE;
            }
            if (b == -1) {
                return Integer.MAX_VALUE;
            }
        }

        int sign = (a > 0) ^ (b > 0) ? -1 : 1;
        if (a > 0) a = -a;
        if (b > 0) b = -b;
        int res = 0;

        while (a <= b) {
            int value = b;
            int k = 1;
            // 0xc0000000 是十进制 -2^30 的十六进制的表示
            // 判断 value >= 0xc0000000 的原因：保证 value + value 不会溢出
            // 可以这样判断的原因是：0xc0000000 是最小值 -2^31 的一半，
            // 而 a 的值不可能比 -2^31 还要小，所以 value 不可能比 0xc0000000 小
            // -2^31 / 2 = -2^30
            while (value >= 0xc0000000 && a <= value + value) {
                value += value;
                // 代码优化：如果 k 已经大于最大值的一半的话，那么直接返回最小值
            // 因为这个时候 k += k 的话肯定会大于等于 2147483648 ，这个超过了题目给的范围
                if (k > Integer.MAX_VALUE / 2) {
                    return Integer.MIN_VALUE;
                }
                k += k;

            }
            a -= value;
            res += k;
        }
    // bug 修复：因为不能使用乘号，所以将乘号换成三目运算符
    return sign == 1 ? res : -res;
    }
}
```
