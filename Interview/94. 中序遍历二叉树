Solution One: Non-recursive
Use color or any other label to record if a node is traversed.
WHITE for not traversed, and GRAY for traversed.
Use stack to store the pair (color, node) of each node
Initialization: push (WHITE, root) into stack, and set res as result array
Loop: Pop the top element from stack. 
      If it's an untraversed node(color is WHITE), push (WHITE, node.right), (GRAY, node), (WHITE, node.left) into stack in order
      If it's an traversed node(color is GRAY), append node.val to result array
Finally, return result array.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((GRAY, node))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        return res


Solution Two: Recursive
Define a method and recursively call it
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def Traversal(subroot, result):
            if not subroot:
                return
            
            Traversal(subroot.left, result)
            result.append(subroot.val)
            Traversal(subroot.right, result)
            
        result = []
        Traversal(root, result)
        return result
